#!/bin/bash
# Distributed under the terms of the GNU General Public License v2
# Copyright 2005-2006 The RepoDoc Team

VERSION="0.1_beta2"

# -----
# SHOW_VERSION_USAGE Function. Private
# Show quick help about how to run repodoc
show_version_usage() {
	echo "The RepoDoc Tool version ${VERSION}"
	echo "Distributed under the terms of the GPLv2"
	echo "Copyright 2005-2006 The RepoDoc Team"
	echo
	echo "Usage: repodoc [--help|-h] [--version|-v] \
[--list-mode|-l] DOCUMENTS "
}

# ------
# CREATE ENVIRONMENT Function. Private
# Create REPO_DIR and REPO_TMP_DIR if needed and clean log
create_environment() {
	# Create dirs. -p will create REPO_DIR if needed.
	[[ -d ${REPO_TMP_DIR} ]] || mkdir -p "${REPO_TMP_DIR}"

	# Remove old log
	[[ -f ${REPODOC_LOG} ]] && rm ${REPODOC_LOG}
}

# ------
# GENERATE OUTPUT Function. Private
#
generate_output() {
	local res OUTPUT_RESULT

	case $1 in
		0)
			OUTPUT_RESULT=ok
			res=$(green 'ok')
		;;
		1)
			OUTPUT_RESULT=warning
			res=$(yellow '??')
		;;
		2)
			OUTPUT_RESULT=critical
			res=$(red '!!')
		;;
	esac

	echo -e "[ ${res} ]"

	# Log message
	if ${GENERATE_LOG} ; then
		# Module header
		cat << EOF >> ${REPODOC_LOG}
------- Module ${MODULE_NAME} -------
Result: ${OUTPUT_RESULT}

EOF

		# Checking if output is not empty
		if [[ -n ${OUTPUT_TEXT} ]]; then
			# Output is just plain text
			cat <<- EOF >> ${REPODOC_LOG}
		Reason:
		${OUTPUT_TEXT}
		EOF
		fi

		return $1
	else
		return 0
	fi
}

# ------
# SHOW LOG Function. Private
#
show_log() {
	local LOG_VIEWER TMP_OPT

	# Set up the log viewer app
	LOG_VIEWER="${PAGER:-less} ${REPODOC_LOG}"

	echo
	echo -n "Do you want to see the error log? [y/N] "
	read -n 1 TMP_OPT
	[[ ${TMP_OPT} = "y" ]] && ${LOG_VIEWER}
	echo
}

#
# MAIN CODE
# Program starts here
#

# Knowing Script dir beware of symlink
[[ -L ${0} ]] && TMP_SCRIPT_DIR=$(readlink ${0}) || TMP_SCRIPT_DIR=${0}
SCRIPT_DIR="${TMP_SCRIPT_DIR%/*}"

# Paths
MOD_DIR="${SCRIPT_DIR}/modules/repodoc"
EXTRA_DIR="${SCRIPT_DIR}/extras"
LIB_DIR="${SCRIPT_DIR}/lib"
MOD_COMM="${MOD_DIR}/commons"
MOD_TRANS="${MOD_DIR}/trans"
MOD_HAND="${MOD_DIR}/handbook"
REPO_DIR="${HOME}/.repodoc"
REPO_TMP_DIR="${REPO_DIR}/tmp"
REPO_CONF_DIR="${REPO_DIR}/config"
REPODOC_LOG="${REPO_DIR}/repodoc.log"

# Misc vars
COLS=$(stty size)
COLS=${COLS##* }

# Options by default
SHOW_INFO=true
SHOW_ALL_RESULTS=true
GENERATE_LOG=true

# Importing libs
source "${LIB_DIR}/libcore.sh"
needlib colors.sh xpath.sh xml.sh docpath.sh

# If no args, show usage
[[ $# -eq 0 ]] && { show_version_usage; exit 0; }

# Check version/help and specific options request
case $1 in
	-v|--version)
		echo "RepoDoc ${VERSION}"
		exit 0
	;;
	-h|--help)
		show_version_usage
		exit 0
	;;
	-l|--list-mode)
		SHOW_INFO=false
		SHOW_ALL_RESULTS=false
		GENERATE_LOG=false
		shift
	;;
esac

## Check every argument
while [[ -n $1 ]] ; do
	# Getting the doc_name and dir taking care of
	# param as a dir (absolute or relative path)
	# or as file.

	unset global_result

	# Adjusting the main variables
	DOC_NAME=${1##*/}
	DIR=$(build-full-path ${1})
	DOC=${DIR}/${DOC_NAME}

	shift

	# Check if doc exists
	if [[ ! -f ${DOC} ]] ; then
		echo "Document Not Found!"
		echo "${DOC_NAME} does not exist in ${DIR}"
		continue
	fi

	# Starting environment and variables
	create_environment
	DOMAIN=$(extract-doc-domain ${DOC})
	LANGUAGE=$(extract-doc-language ${DIR})
	WWW_DIR=$(extract-web-dir ${DIR})
	CVS_ROOT=$(extract-cvs-root ${DIR})
	DOC_TYPE=$(get-xmldoctype ${DOC})
	ORIGINAL_DOC=$(localize-path ${DOC} "en")
	[[ "${LANGUAGE}" == "en" ]] && TRANSLATION=false || TRANSLATION=true

	if ${SHOW_INFO} ; then
		echo " ---------- Info ------------------------------"
		echo "Doc: " ${DOC_NAME}
		echo "Dir: " ${DIR}
		echo "Lang: " ${LANGUAGE}
		echo -n "Trans: " $(${TRANSLATION} && echo yes || echo no)
		[[ -f ${ORIGINAL_DOC} ]] || echo -n " (OBSOLETE DOCUMENT)"
		echo
		echo "Doc-type: " ${DOC_TYPE}
		#echo "www-dir: " $WWW_DIR
		#echo "domain: " $DOMAIN
		#echo "cvs_root: " $CVS_ROOT

		#echo "original_doc: " $ORIGINAL_DOC
		#echo "Level: " $SCRIPT_LEVEL
		echo " ----------------------------------------------"
		echo
	fi

	${SHOW_ALL_RESULTS} || printf " * %-*s " $((COLS-10)) "${WWW_DIR}/${DOC_NAME}"

	# Set up VIEW_LOG to "false" until an error appears
	VIEW_LOG=false

	# Handling modules
	for MOD in ${MOD_DIR}/* ; do
		# This vars are set by the modules. This is a pedantic thing
		#  meant to help me keeping my sanity.
		# TODO: Remove this once we figure out how to cleanly do the
		#  whole module processing in a subshell.
		unset OUTPUT_TEXT LEVEL MODULE_NAME KEYWORDS exec_module ${!NEED_*} n needtest

		# Read the module
		source "${MOD}"

		for n in ${!NEED_*} ; do
			needtest=$(eval echo $\{${n##NEED_}\})
			${needtest} || continue 2
		done

		# Parse KEYWORDS properly
		GLOBIGNORE=*
		execmodule=false

		for k in ${KEYWORDS} ; do
			case ${k} in
				'ALL'|'*'|"${DOC_TYPE}")    execmodule=true  ;;
				'-ALL'|'-*'|"-${DOC_TYPE}") execmodule=false ;;
			esac
		done

		# Restore GLOBIGNORE to avoid difficult to debug problems.
		unset GLOBIGNORE

		tmpmod=${MOD##*/}

		if ${execmodule} ; then
			${SHOW_ALL_RESULTS} && printf " * Processing module %-10s " ${tmpmod%.module}
			# Call exec_module (function from module). generate_output is
			# a bit special since it propagates its argument as its exit status.
			exec_module
			result=$?
			if ${SHOW_ALL_RESULTS} ; then
				generate_output ${result} || VIEW_LOG=true
			else
				[[ ${result} -gt ${global_result:=0} ]] && global_result=${result}
			fi
		fi
	done

	${SHOW_ALL_RESULTS} || generate_output ${global_result} || VIEW_LOG=true

	# Show the log if needed
	${VIEW_LOG} && show_log

done
