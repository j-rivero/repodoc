#!/bin/bash

# Repodoc Tool written by Jos√© Luis Rivero (yoswink@gentoo.org)
# Version 0.1_alpha
#
# Repodoc try to make Gentoo Documentation Project Developer's
# work easier (yeah! we are slackers).
# Thanks a lot to Fernando J. Pereda (ferdy@gentoo.org) who
# is my bash-ninja-sensei.
#
# Distributed under the terms of the GNU General Public License v2

VERSION="0.1_alpha"

# ------
# CHECK_PARAMS Function. Private
# Check params to be sure the program was called properly.
#check_params () {
	# Check if the program receives only one param and if
	# the param is a file
#	if [[ ${NUM_PARAMS} != 1 ]] || [[ ! -f ${PARAM1} ]]; then
#		show_version_usage
#		exit
#	fi
#}

# -----
# SHOW_VERSION_USAGE Function. Private
# Show quick help about how to run repodoc
show_version_usage() {
	echo "Repodoc ${VERSION}"
	echo
	echo "Usage: repodoc [doc]"
}

# -----
# SEARCH DIR_ROOT Function. Private
#
search_dir_root() {
	local DIR_ROOT_TMP

	# The dir root is the first cvs tree subdir after htdocs
	DIR_ROOT_TMP=${DIR##*htdocs\/}
	DIR_ROOT=${DIR_ROOT_TMP%%\/*}
}

# ------
# SEARCH LANGUAGE Function. Private
#
search_language() {
	# Taking DIR as base, the language will appear after DIR_ROOT
	# First, cutting all before DIR_ROOT
	TMP1=${DIR##*/$DIR_ROOT/}

	# Next "/item/" after DIR_ROOT should be the language
	LANGUAGE=${TMP1%%/*}

	# Set translation variable
	[[ ${LANGUAGE} = "en" ]] && TRANSLATION=false || TRANSLATION=true
}

# ------
# SEARCH ORIGINAL_DOC Function. Private
# Search for path of original version only in case of doc is a translation
search_original_doc() {
	# Just need to change /$language/ by /en/ in doc path to obtain the original version
	ORIGINAL_DOC=$(sed -e "s:${DIR_ROOT}/${LANGUAGE}:${DIR_ROOT}/en:g" <<< ${DOC})

	# If this document is obsolete, it is NOT a translation
	[[ -f ${ORIGINAL_DOC} ]] || TRANSLATION=false
}


# -----
# SEARCH WWW_DIR Function. Private
#
search_www_dir() {
	# Obtaining the www dir where the doc is placed
	WWW_DIR=${DIR/*${DIR_ROOT}/\/${DIR_ROOT}}
}


# ------
# CREATE ENVIRONMENT Function. Private
# Create REPO_DIR and REPO_TMP_DIR if needed and clean log
create_environment() {
	# Create dirs. -p will create REPO_DIR if needed.
	[[ -d ${REPO_TMP_DIR} ]] || mkdir -p "${REPO_TMP_DIR}"

	# Remove old log
	[[ -f ${REPODOC_LOG} ]] && rm ${REPODOC_LOG}
}


# ------
# SEARCH DOCTYPE Function. Private
#
search_doctype() {
	local TMP_DOC_TYPE TMP

	# sed -n -e '/<!DOCTYPE \([^ ]*\) .*/{s--\1-p;q}' blah.xml
	TMP_DOC_TYPE=$(grep -m 1 DOCTYPE ${DOC})
	TMP_DOC_TYPE=${TMP_DOC_TYPE##<!DOCTYPE }
	DOC_TYPE=${TMP_DOC_TYPE%% SYSTEM*}
}


# ------
# SEARCH CVS_ROOT Function. Private
#
search_cvs_root() {
	CVS_ROOT=${DIR%%$WWW_DIR}
}



# ------
# GENERATE OUTPUT Function. Private
#
generate_output() {
	local res OUTPUT_RESULT

	case $1 in
		0) OUTPUT_RESULT=ok ;;
		1) OUTPUT_RESULT=warning ;;
		2) OUTPUT_RESULT=critical ;;
	esac

	case ${OUTPUT_RESULT} in
		ok) res='\033[01;32mok' ;;
		warning) res='\033[01;33m??' ;;
		critical) res='\033[01;31m!!' ;;
	esac

	echo -e "[ ${res}\033[00m ]"

	# Log message

	# Module header
	cat << EOF >> ${REPODOC_LOG}
------- Module ${MODULE_NAME} -------
Result: ${OUTPUT_RESULT}

EOF

	# Checking if output is not empty
	if [[ -n ${OUTPUT_TEXT} ]]; then
		# Output is just plain text
		cat <<- EOF >> ${REPODOC_LOG}
		Reason:
		${OUTPUT_TEXT}
		EOF
	fi

	return $1
}

# ------
# SHOW LOG Function. Private
#
show_log() {
	local LOG_VIEWER TMP_OPT

	# Set up the log viewer app
	LOG_VIEWER="less ${REPODOC_LOG}"

	echo
	echo -n "Do you want to see the error log? [y/N] "
	read TMP_OPT
	[[ ${TMP_OPT} = "y" ]] && ${LOG_VIEWER}
}


#
# MAIN CODE
# Program starts here
#

# -- VARIABLES --

NUM_PARAMS="$#"
PARAM1=$1

# Checks if the params given to the app were correct
#check_params

# Knowing Script dir beware of symlink
[[ -L ${0} ]] && TMP_SCRIPT_DIR=$(readlink ${0}) || TMP_SCRIPT_DIR=${0}
SCRIPT_DIR="${TMP_SCRIPT_DIR%/*}"

# Paths
MOD_DIR="${SCRIPT_DIR}/modules"
EXTRA_DIR="${SCRIPT_DIR}/extras"
MOD_COMM="${MOD_DIR}/commons"
MOD_TRANS="${MOD_DIR}/trans"
MOD_HAND="${MOD_DIR}/handbook"
REPO_DIR="${HOME}/.repodoc"
REPO_TMP_DIR="${REPO_DIR}/tmp"
REPODOC_LOG="${REPO_DIR}/repodoc.log"

## Check every argument
while [[ -n $1 ]] ; do
	# Getting the doc_name and dir taking care of
	# param as a dir (absolute or relative path)
	# or as file.

	tmpdir=${1%/*}
	[[ ${tmpdir} = $1 ]] && tmpdir=.

	pushd ${tmpdir} > /dev/null
	dir=${PWD}
	popd > /dev/null

	name=${1##*/}

	shift

	# Adjusting the main variables
	DOC_NAME=${name}
	DIR=${dir}
	DOC=${DIR}/${DOC_NAME}

	# Check if doc exists
	[[ -f ${DOC} ]] || {
		echo "Doc Not Found!"
		echo "${DOC_NAME} does not exist in ${DIR}"
		continue
	}

	#SCRIPT_LEVEL="BASIC"

	# Starting environment and variables
	create_environment
	search_dir_root
	search_language
	search_original_doc
	search_www_dir
	search_doctype
	search_cvs_root

	echo " ---------- Info ------------------------------"
	echo "Doc: " ${DOC_NAME}
	echo "Dir: " ${DIR}
	echo "Lang: " ${LANGUAGE}
	echo -n "Trans: " $(${TRANSLATION} && echo yes || echo no)
	[[ -f ${ORIGINAL_DOC} ]] || echo -n " (OBSOLETE DOCUMENT)"
	echo
	echo "Doc-type: " ${DOC_TYPE}
	#echo "www-dir: " $WWW_DIR
	#echo "dir-root: " $DIR_ROOT
	#echo "cvs_root: " $CVS_ROOT

	#echo "original_doc: " $ORIGINAL_DOC
	#echo "Level: " $SCRIPT_LEVEL
	echo " ----------------------------------------------"
	echo

	# Set up VIEW_LOG to "false" until an error appears
	VIEW_LOG=false

	# Handling modules
	for MOD in ${MOD_DIR}/* ; do
		# Initializing variables
		TRANSLATION_MODULE=""
		OUTPUT_TEXT=""
		LEVEL=""

		# Read the module
		source "${MOD}"

		# Parse KEYWORDS properly
		GLOBIGNORE=*
		execmodule=false

		for k in ${KEYWORDS} ; do
			case ${k} in
				'ALL'|'*'|"${DOC_TYPE}")    execmodule=true  ;;
				'-ALL'|'-*'|"-${DOC_TYPE}") execmodule=false ;;
			esac
		done

		# Restore GLOBIGNORE
		unset GLOBIGNORE

		tmpmod=${MOD##*/}

		if ${execmodule} ; then
			printf " * Processing module %-10s " ${tmpmod%.module}
			# Call exec_module (function from module)
			exec_module
			generate_output $? || VIEW_LOG=true
		fi
	done

	# Show the log if needed
	${VIEW_LOG} && show_log
done
